# 第8章 异常控制流

## 8.1 异常

- 异常就是控制流中的突变，用来响应处理器状态中的某些变化。

![image-20220304100307038](dependence/image-20220304100307038.png)

当处理器检测到有事件发生时，就通过异常表的跳转表，进行一个间接过程调用，到一个专门处理这类事件的OS子程序。

### 8.1.1 异常处理

系统中可能的每种类型异常都分配了一个唯一的非负整数：异常号。其中一些由处理器设计者分配，另一些由OS内核(OS常驻内存部分)设计者分配。前者包括被零除、缺页、内存方文伟里、断点以及算数溢出；后者包括系统调用、外部I/O信号。

在系统启动时，OS分配和初始化**异常表**。异常号到是到异常表的索引，异常表的起始地址放在**异常表基址寄存器**中。

![image-20220304101001649](dependence/image-20220304101001649.png)

异常调用类似过程调用，但也有不同：

1. 过程调用过程调用时， 在跳转到处理程序之前，处理器将返回地址压入栈中。然而根据异常的类型，返回地址要么是当前指令(当事件发生时正在执行的指令)，要么是下一条指令。
2. 处理器也会把一些额外的处理器状态压入栈中，当处理程序返回，重新开始执行被中断程序会需要这些状态。
3. 如果控制从用户程序转移到内核，这些项目都被压到内核栈中，而不是用户栈中。
4. 异常处理程序运行在内核模式下，所以它们对所有系统资源都有完全访问权限。

### 8.1.2 异常的类别

| 类别 | 原因              | 异步/同步 | 返回行为             |
| ---- | ----------------- | --------- | -------------------- |
| 中断 | 来自I/O设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常        | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误    | 同步      | 不会返回             |

异步：异常不是由任何专门指令造成的。

同步：异常是执行当前指令的结果。

---

- 中断

中断是来自CPU外部的I/O设备的信号的结果。它不由任何一条专门的指令造成，所以它是异步的。



- 陷阱和系统调用

陷阱是有意的异常，是一条指令的结果。陷阱最重要的用途就是**在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用**。

用户经常需要向内核请求服务，如读文件(read)、创建新的进程(fork)、加载新程序(execve)，终止当前进程(exit)。**为了允许对这些内核服务的受控的访问，CPU提供了"syscall n"指令**。执行syscall指令会导致一个陷阱的异常处理程序，它可以解析参数并调用适当的内核程序。



普通函数运行在**用户模式**，限制了函数可以执行的指令的类型，而且只能访问与调用函数相同的栈。系统调用运行在**内核模式**，允许系统调用执行特权指令，并访问定义在内核中的栈。



- 故障

故障由错误情况引起，可能可以被故障处理程序修正。如果CPU能修正，就将控制返回到引起故障的指令，重新执行；否则处理程序返回内核中的abort例程，终止程序。

![image-20220304102816214](dependence/image-20220304102816214.png)

一个经典的故障就是缺页异常。当指令引用一个虚拟地址，而与改地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，就可以正常运行了。



- 终止

通常是一些硬件错误，不可恢复。处理程序直接交给abort例程，终止程序。

---

### 8.1.3 Linux/x86-64系统中的异常

所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。

![image-20220304105856230](dependence/image-20220304105856230.png)

```c
int main(){
    write(1,"hello, world\n",13);
    _exit(0);
}
```

write函数的第一个参数将输出发送到stdout。第二个参数是要写的字节序列，第三个参数是要写的字节数。

## 8.2 进程

- 进程的经典定义：一个执行中程序的实例。

系统中的每个程序都运行在某个进程上下文中。

### 8.2.2 并发流

- 一个逻辑流的执行在时间上与另一个流重叠，称为**并发流**。多个流并发的执行被称为**并发**。

![image-20220304144705585](dependence/image-20220304144705585.png)

### 8.2.3 私有地址空间

进程为每个程序提供一种假象，好像它独占地使用系统地址空间。

![image-20220304152847516](dependence/image-20220304152847516.png)

### 8.2.4 用户模式和内核模式

CPU通过某个控制寄存器中的一个**模式位**描述进程当前享有的特权：内核模式和用户模式。

![image-20220304153308838](dependence/image-20220304153308838.png)



Linux提供/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容的内容输出位一个用户程序可以读的文本文件的层次结构。比如CPU类型(/proc/cpuinfo)

### 8.2.5 上下文切换

- 内核为每个进程维持一个上下文



























































