# 条款1 视C++为一个语言联邦

没啥好说的

# 条款2 尽量以const, enum, inline替换#define

## 宏定义的变量可能不会进入符号表(symbol table)

在define之后，可能在运用该常量的过程中获得一个编译错误，这个错误也许会提到定义的结果，而不会提到那个常量的名字，这样会导致困惑，因为需要追踪那个常量就显得十分困难。

const定义的**语言常量**肯定会被编译器看到，因此会进入符号表

## 宏定义无法创建class专属常量

**#define 不重视作用域**

一旦宏被定义，就在其后的变异过程中有效  所以#define也没有封装性

## 一个属于枚举类型的数值可以充当int使用

```
#class GamePlayer{
private:
	enum{NumTurns=5};

	int scores[NumTurns];
};
```

## 对于形如函数的宏，最好用inline函数替换#define

**现代编译器会自动inline，而不是根据编写代码者是否添加inline来判断**

# 条款3 尽可能使用const

T* const  指针不得指向不同东西

const T*       T const*   指针指向的东西不可变动

**class的const成员函数可以操作const对象**

**如果函数返回类型是内置类型，那么改动函数返回值不合法**    **对返回值的改动必须要求函数返回值是左值引用**

**const成员函数可以使用类的成员，但不能修改他们**

**类的const成员变量（常量）只能通过构造函数的初始化列表**

# 条款4 确定对象被使用前已被初始化

**在使用前确保初始化**

**构造函数一定要用member initialization list进行构造 而不是对于每个成员挨个赋值**

**原因在于 基于赋值的版本会先调用default构造函数对成员进行默认初始化，然后再调用这个版本的构造函数进行赋值动作的初始化**

**效率远远不如member initialization list的构造**

**如果成员变量是const或reference，就一定需要初值，不能被赋值**

**C++有十分固定的成员初始化次序，class的成员变量总是以其声明次序被初始化，不论它们在构造函数中的顺序是什么样的 但是最好按照声明顺序进行初始化**

**Singleton模式**：

C++在多单元编译的时候  编译顺序具有不确定性  **以local static对象 替换non-local static对象**   **这部分注意看原书**

# 条款5 了解C++默默编写并调用哪些函数

默认函数只在被需要的时候才产生

编译器产出的析构函数是non-virtual的

**在内含const成员、reference成员的类中，编译器会拒绝编译赋值操作的代码。因为C++并不允许 让reference和const对象改指向不同对象**

# 条款6 若不想使用编译器自动生成的函数，就该明确拒绝

侯捷给出的做法是将拷贝相关函数声明为private并且不予实现  **过时**

C++11可以通过在相关函数的声明后跟=delete 实现删除该函数

1.将拷贝函数声明为private并不绝对安全 因为成员函数和友元函数还是可以调用private函数

2.如果定义为private且不定义的话  对它们的调用将会获得一个 **链接错误**

所以其实还是不太方便

# 条款7 为多态基类声明virtual析构函数

派生类对象被绑定到基类指针或者引用上  在调用析构函数时，如果不是virtual析构函数，那么派生类中的部分没有被销毁

**欲实现virtual函数 对象必须携带某些信息 主要用来在运行期决定哪一个virtual函数被调用**  **这些信息通常由vptr指针指出  vptr指向一个由函数指针构成的数组，称为vtbl(virtual table)**   **每一个带有virtual函数的class都有一个相应的vtbl 当对象调用某一virtual函数 实际上取决于该对象的vptr所指向的那个vtbl**

**如果类内包含virtual函数，其对象体积会增加**

# 条款8 别让异常逃离析构函数

类不希望析构函数可以产生异常

析构函数应该捕捉任何异常 然后吞下它们或结束程序

如果需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数而非在析构函数中执行该操作

# 条款9 绝不在构造或析构函数中调用virtual函数

如果在构造函数中调用virtual函数  那么创建一个派生类对象的时候 基类构造优先于派生类构造 此时调用的virtual函数是基类的对应函数  **因为在base class构造期间 virtual函数不是virtual函数** 

**在派生类对象的基类构造期间，对象的类型是base class而不是derived class**

不止virtual函数会被编译器解析之base class，如果使用运行期类型信息 入dynamic-cast和typeid 也会把对象视作base class

一个可行的做法是 在derived class的构造函数中 将一个static派生类对象作为参数传递给base class的构造函数  这样就避免了调用一个未初始化/未生成的对象

# 条款10 令operator=返回一个reference to *this

内置数据类型可以连锁赋值   如果希望自定义数据类型也支持连锁赋值 **那么必须令operator=返回一个*this的引用** 

# 条款11 在operator=中处理“自我赋值”

不要认为自我赋值不存在  

```cpp
a[i]=a[j]   //潜在的自我赋值
```

这一类并不明显的自我赋值  是“别名”带来的结果

**一般来说  在operator=的最前面加上一个“证同测试”即可**  但是这个方法不是异常安全的  

**正确操作：记住原来的 令其指向新的  再删除它**

# 条款12 复制对象时勿忘其每一个成分

当为派生类写拷贝函数的时候必须要考虑到base class的成分   那些成分有可能还private的  所以必须小心复制base class成分  调用base class的拷贝函数

**不应该让拷贝复制操作符调用拷贝构造函数**

当发现拷贝构造函数和拷贝赋值操作符之间有相近的代码  消除重复代码的做法是 建立一个新的成员函数给两个函数调用  **该函数一般是private的  且常被命名为init**

